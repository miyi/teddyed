"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Inspired by https://github.com/zeit/now-cli/blob/canary/download/src/index.js
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
// Packages
const death_1 = __importDefault(require("death"));
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const make_dir_1 = __importDefault(require("make-dir"));
// Utils
const log_1 = require("./log");
const chmod_1 = __importDefault(require("./chmod"));
const copy_1 = require("./copy");
const getos_1 = require("./getos");
const downloadZip_1 = require("./downloadZip");
const util_2 = require("./util");
const debug = debug_1.default('download');
const writeFile = util_1.promisify(fs_1.default.writeFile);
const exists = util_1.promisify(fs_1.default.exists);
const channel = 'alpha';
async function download(options) {
    const mergedOptions = Object.assign({ platforms: [await getos_1.getPlatform()], version: 'latest' }, options);
    const binaryNames = Object.keys(mergedOptions.binaries);
    const binaryStr = binaryNames.length > 1 ? `${binaryNames.join(' and ')} binaries` : `${binaryNames[0]} binary`;
    const bar = options.showProgress ? log_1.getBar(`Downloading ${binaryStr}`) : undefined;
    const progressMap = {};
    // Object.values is faster than Object.keys
    const numDownloads = Object.values(mergedOptions.binaries).length * Object.values(mergedOptions.platforms).length;
    const collectiveCallback = options.progressCb || options.showProgress
        ? (sourcePath) => progress => {
            progressMap[sourcePath] = progress;
            const progressValues = Object.values(progressMap);
            const totalProgress = progressValues.reduce((acc, curr) => {
                return acc + curr;
            }, 0) / numDownloads;
            if (options.progressCb) {
                options.progressCb(totalProgress);
            }
            if (bar) {
                bar.update(totalProgress);
            }
        }
        : undefined;
    await Promise.all(Object.entries(options.binaries).map(([binaryName, targetDir]) => {
        return Promise.all(mergedOptions.platforms.map(platform => {
            const sourcePath = util_2.getDownloadUrl(channel, mergedOptions.version, platform, binaryName);
            const targetPath = path_1.default.resolve(targetDir, `${binaryName}-${platform}`);
            return downloadBinary({
                sourcePath,
                binaryName: binaryName,
                platform,
                version: mergedOptions.version,
                targetPath,
                progressCb: collectiveCallback ? collectiveCallback(sourcePath) : undefined,
            });
        }));
    }));
    if (bar) {
        bar.update(1);
        bar.terminate();
    }
}
exports.download = download;
async function downloadBinary({ sourcePath, targetPath, version, platform, progressCb, binaryName, }) {
    await make_dir_1.default(path_1.default.dirname(targetPath));
    debug(`Downloading ${sourcePath} to ${targetPath}`);
    try {
        fs_1.default.writeFileSync(targetPath, '#!/usr/bin/env node\n' + `console.log("Please wait until the \'prisma ${binaryName}\' download completes!")\n`);
    }
    catch (err) {
        if (err.code === 'EACCES') {
            log_1.warn('Please try installing Prisma 2 CLI again with the `--unsafe-perm` option.');
            log_1.info('Example: `npm i -g --unsafe-perm prisma2`');
            process.exit();
        }
        throw err;
    }
    death_1.default(() => {
        fs_1.default.writeFileSync(targetPath, '#!/usr/bin/env node\n' +
            `console.log("The \'prisma ${binaryName}\' download did not complete successfully.")\n` +
            'console.log("Please run \'npm i -g prisma2\' to reinstall!")\n');
        process.exit();
    });
    // Print an empty line
    const cacheDir = await util_2.getCacheDir(channel, version, platform);
    const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
    const cachedLastModifiedPath = path_1.default.join(cacheDir, 'lastModified-' + binaryName);
    const [cachedPrismaExists, localLastModified] = await Promise.all([
        exists(cachedTargetPath),
        util_2.getLocalLastModified(cachedLastModifiedPath),
    ]);
    if (cachedPrismaExists && localLastModified) {
        const remoteLastModified = await util_2.getRemoteLastModified(sourcePath);
        // If there is no new binary and we have it localy, copy it over
        if (localLastModified >= remoteLastModified) {
            await copy_1.copy(cachedTargetPath, targetPath);
            return;
        }
    }
    if (progressCb) {
        progressCb(0);
    }
    const lastModified = await downloadZip_1.downloadZip(sourcePath, targetPath, progressCb);
    if (progressCb) {
        progressCb(1);
    }
    chmod_1.default(targetPath);
    try {
        await copy_1.copy(targetPath, cachedTargetPath);
        await writeFile(cachedLastModifiedPath, lastModified);
    }
    catch (e) {
        debug({ sourcePath, targetPath }, e);
        // let this fail silently - the CI system may have reached the file size limit
    }
}
//# sourceMappingURL=download.js.map