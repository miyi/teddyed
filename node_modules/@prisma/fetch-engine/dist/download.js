"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Inspired by https://github.com/zeit/now-cli/blob/canary/download/src/index.js
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const chalk_1 = __importDefault(require("chalk"));
// Packages
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const make_dir_1 = __importDefault(require("make-dir"));
// Utils
const log_1 = require("./log");
const chmod_1 = __importDefault(require("./chmod"));
const copy_1 = require("./copy");
const get_platform_1 = require("@prisma/get-platform");
const downloadZip_1 = require("./downloadZip");
const util_2 = require("./util");
const debug = debug_1.default('download');
const writeFile = util_1.promisify(fs_1.default.writeFile);
const exists = util_1.promisify(fs_1.default.exists);
const channel = 'master';
async function download(options) {
    const platform = await get_platform_1.getPlatform();
    const mergedOptions = Object.assign({ binaryTargets: [platform], version: 'latest' }, options, { binaries: mapKeys(options.binaries, key => engineTypeToBinaryType(key, platform)) });
    const plural = mergedOptions.binaryTargets.length > 1 ? 'ies' : 'y';
    const bar = options.showProgress
        ? log_1.getBar(`Downloading ${mergedOptions.binaryTargets
            .map(p => chalk_1.default.bold(p))
            .join(' and ')} binar${plural} for ${Object.keys(mergedOptions.binaries).join(' and ')}`)
        : undefined;
    const progressMap = {};
    // Object.values is faster than Object.keys
    const numDownloads = Object.values(mergedOptions.binaries).length * Object.values(mergedOptions.binaryTargets).length;
    const collectiveCallback = options.progressCb || options.showProgress
        ? (sourcePath) => progress => {
            progressMap[sourcePath] = progress;
            const progressValues = Object.values(progressMap);
            const totalProgress = progressValues.reduce((acc, curr) => {
                return acc + curr;
            }, 0) / numDownloads;
            if (options.progressCb) {
                options.progressCb(totalProgress);
            }
            if (bar) {
                bar.update(totalProgress);
            }
        }
        : undefined;
    const binaryPaths = Object.keys(options.binaries).reduce((acc, curr) => {
        acc[curr] = {};
        return acc;
    }, {});
    await Promise.all(Object.entries(options.binaries).map(([binaryName, targetDir]) => {
        return Promise.all(mergedOptions.binaryTargets.map(async (platform) => {
            const sourcePath = util_2.getDownloadUrl(channel, mergedOptions.version, platform, binaryName);
            const targetPath = path_1.default.resolve(targetDir, getBinaryName(binaryName, platform));
            binaryPaths[binaryName][platform] = targetPath;
            if (!options.skipDownload) {
                await downloadBinary({
                    sourcePath,
                    binaryName: binaryName,
                    platform,
                    version: mergedOptions.version,
                    targetPath,
                    progressCb: collectiveCallback ? collectiveCallback(sourcePath) : undefined,
                });
            }
        }));
    }));
    if (bar) {
        bar.update(1);
        bar.terminate();
    }
    return binaryPaths;
}
exports.download = download;
function getBinaryName(binaryName, platform) {
    const extension = platform === 'windows' ? '.exe' : '';
    if (binaryName === 'migration-engine') {
        return 'migration-engine' + extension;
    }
    return `${binaryName}-${platform}${extension}`;
}
async function downloadBinary({ sourcePath, targetPath, version, platform, progressCb, binaryName, }) {
    await make_dir_1.default(path_1.default.dirname(targetPath));
    debug(`Downloading ${sourcePath} to ${targetPath}`);
    try {
        fs_1.default.writeFileSync(targetPath, '#!/usr/bin/env node\n' + `console.log("Please wait until the \'prisma ${binaryName}\' download completes!")\n`);
    }
    catch (err) {
        if (err.code === 'EACCES') {
            log_1.warn('Please try installing Prisma 2 CLI again with the `--unsafe-perm` option.');
            log_1.info('Example: `npm i -g --unsafe-perm prisma2`');
            process.exit();
        }
        throw err;
    }
    // Print an empty line
    const cacheDir = await util_2.getCacheDir(channel, version, platform);
    const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
    const cachedLastModifiedPath = path_1.default.join(cacheDir, 'lastModified-' + binaryName);
    const [cachedPrismaExists, localLastModified] = await Promise.all([
        exists(cachedTargetPath),
        util_2.getLocalLastModified(cachedLastModifiedPath),
    ]);
    if (cachedPrismaExists && localLastModified) {
        const remoteLastModified = await util_2.getRemoteLastModified(sourcePath);
        // If there is no new binary and we have it localy, copy it over
        if (localLastModified >= remoteLastModified) {
            await copy_1.copy(cachedTargetPath, targetPath);
            return;
        }
    }
    if (progressCb) {
        progressCb(0);
    }
    const lastModified = await downloadZip_1.downloadZip(sourcePath, targetPath, progressCb);
    if (progressCb) {
        progressCb(1);
    }
    chmod_1.default(targetPath);
    try {
        await copy_1.copy(targetPath, cachedTargetPath);
        await writeFile(cachedLastModifiedPath, lastModified);
    }
    catch (e) {
        debug({ sourcePath, targetPath }, e);
        // let this fail silently - the CI system may have reached the file size limit
    }
}
function engineTypeToBinaryType(engineType, platform) {
    if (engineType === 'introspectionEngine') {
        return 'introspection-engine'; // TODO: Remove as any as soon as type added to @prisma/fetch-engine
    }
    if (engineType === 'migrationEngine') {
        return 'migration-engine';
    }
    if (engineType === 'queryEngine') {
        return 'query-engine';
    }
    if (engineType === 'native') {
        return platform;
    }
    return engineType;
}
function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[mapper(key)] = value;
        return acc;
    }, {});
}
//# sourceMappingURL=download.js.map