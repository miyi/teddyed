"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Engine_1 = require("./Engine");
const got_1 = __importDefault(require("got"));
const debug_1 = __importDefault(require("debug"));
const get_platform_1 = require("@prisma/get-platform");
const path_1 = __importDefault(require("path"));
const net_1 = __importDefault(require("net"));
const fs_1 = __importDefault(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const printGeneratorConfig_1 = require("./printGeneratorConfig");
const util_1 = require("./util");
const util_2 = require("util");
const events_1 = __importDefault(require("events"));
const log_1 = require("./log");
const child_process_1 = require("child_process");
const byline_1 = __importDefault(require("./byline"));
const debug = debug_1.default('engine');
const exists = util_2.promisify(fs_1.default.exists);
/**
 * Node.js based wrapper to run the Prisma binary
 */
const knownPlatforms = [
    'native',
    'darwin',
    'windows',
    'linux-glibc-libssl1.0.1',
    'linux-glibc-libssl1.0.2',
    'linux-glibc-libssl1.0.2-ubuntu1604',
    'linux-glibc-libssl1.1.0',
    'windows',
];
class NodeEngine extends Engine_1.Engine {
    constructor(_a) {
        var { cwd, datamodel, prismaPath, generator, datasources } = _a, args = __rest(_a, ["cwd", "datamodel", "prismaPath", "generator", "datasources"]);
        super();
        /**
         * exiting is used to tell the .on('exit') hook, if the exit came from our script.
         * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore
         */
        this.exiting = false;
        this.managementApiEnabled = false;
        this.ready = false;
        this.stderrLogs = '';
        this.stdoutLogs = '';
        this.fail = async (e, why) => {
            debug(e, why);
            await this.stop();
        };
        this.cwd = this.resolveCwd(cwd);
        this.debug = args.debug || false;
        this.datamodel = datamodel;
        this.prismaPath = prismaPath;
        this.platform = process.env.PRISMA_QUERY_ENGINE_BINARY;
        this.generator = generator;
        this.datasources = datasources;
        this.logEmitter = new events_1.default();
        this.logEmitter.on('log', log => {
            if (log.level === 'error') {
                this.lastError = log;
                if (log.message === 'PANIC') {
                    this.handlePanic(log);
                }
            }
            if (this.debug) {
                debug_1.default('engine:log')(log);
            }
        });
        if (this.platform) {
            if (!knownPlatforms.includes(this.platform) && !fs_1.default.existsSync(this.platform)) {
                throw new Error(`Unknown ${chalk_1.default.red('PRISMA_QUERY_ENGINE_BINARY')} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(', '))} or a path to the query engine binary.
You may have to run ${chalk_1.default.greenBright('prisma2 generate')} for your changes to take effect.`);
            }
        }
        else {
            this.getPlatform();
        }
        if (this.debug) {
            debug_1.default.enable('*');
        }
    }
    resolveCwd(cwd) {
        if (cwd && fs_1.default.existsSync(cwd) && fs_1.default.lstatSync(cwd).isDirectory()) {
            return cwd;
        }
        return process.cwd();
    }
    on(event, listener) {
        this.logEmitter.on(event, listener);
    }
    async getPlatform() {
        if (this.platformPromise) {
            return this.platformPromise;
        }
        this.platformPromise = get_platform_1.getPlatform();
        return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
        let queryEnginePath = path_1.default.join(prefix, `query-engine-${platform}`);
        if (platform === 'windows') {
            queryEnginePath = `${queryEnginePath}.exe`;
        }
        return queryEnginePath;
    }
    handlePanic(log) {
        this.child.kill();
        if (this.currentRequestPromise) {
            ;
            this.currentRequestPromise.cancel();
        }
    }
    async resolvePrismaPath() {
        if (this.prismaPath) {
            return this.prismaPath;
        }
        const platform = await this.getPlatform();
        if (this.platform && this.platform !== platform) {
            this.incorrectlyPinnedPlatform = this.platform;
        }
        this.platform = this.platform || platform;
        const fileName = eval(`require('path').basename(__filename)`);
        if (fileName === 'NodeEngine.js') {
            return this.getQueryEnginePath(this.platform, path_1.default.resolve(__dirname, `..`));
        }
        else {
            return this.getQueryEnginePath(this.platform);
        }
    }
    // If we couldn't find the correct binary path, let's look for an alternative
    // This is interesting for libssl 1.0.1 vs libssl 1.0.2 cases
    async resolveAlternativeBinaryPath(platform) {
        const compatiblePlatforms = knownPlatforms.slice(1).filter(p => get_platform_1.mayBeCompatible(p, platform));
        const binariesExist = await Promise.all(compatiblePlatforms.map(async (platform) => {
            const filePath = this.getQueryEnginePath(platform);
            return {
                exists: await exists(filePath),
                platform,
                filePath,
            };
        }));
        const firstExistingPlatform = binariesExist.find(b => b.exists);
        if (firstExistingPlatform) {
            return firstExistingPlatform.filePath;
        }
        return null;
    }
    // get prisma path
    async getPrismaPath() {
        const prismaPath = await this.resolvePrismaPath();
        const platform = await this.getPlatform();
        if (!(await exists(prismaPath))) {
            let info = '.';
            if (this.generator) {
                const fixedGenerator = Object.assign(Object.assign({}, this.generator), { binaryTargets: util_1.fixPlatforms(this.generator.binaryTargets, this.platform) });
                info = `:\n${chalk_1.default.greenBright(printGeneratorConfig_1.printGeneratorConfig(fixedGenerator))}`;
            }
            const pinnedStr = this.incorrectlyPinnedPlatform
                ? `\nYou incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.incorrectlyPinnedPlatform}`)}\n`
                : '';
            const alternativePath = await this.resolveAlternativeBinaryPath(platform);
            if (!alternativePath) {
                throw new Error(`Photon binary for current platform ${chalk_1.default.bold.greenBright(platform)} could not be found.${pinnedStr}
  Make sure to adjust the generator configuration in the ${chalk_1.default.bold('schema.prisma')} file${info}
  Please run ${chalk_1.default.greenBright('prisma2 generate')} for your changes to take effect.
  ${chalk_1.default.gray(`Note, that by providing \`native\`, Photon automatically resolves \`${platform}\`.
  Read more about deploying Photon: ${chalk_1.default.underline('https://github.com/prisma/prisma2/blob/master/docs/core/generators/photonjs.md')}`)}`);
            }
            else {
                console.error(`${chalk_1.default.yellow('warning')} Photon could not resolve the needed binary for the current platform ${chalk_1.default.greenBright(platform)}.
Instead we found ${chalk_1.default.bold(alternativePath)}, which we're trying for now. In case Photon runs, just ignore this message.`);
                util_1.plusX(alternativePath);
                return alternativePath;
            }
        }
        if (this.incorrectlyPinnedPlatform) {
            console.log(`${chalk_1.default.yellow('Warning:')} You pinned the platform ${chalk_1.default.bold(this.incorrectlyPinnedPlatform)}, but Photon detects ${chalk_1.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${chalk_1.default.greenBright(await this.getPlatform())} instead.
${chalk_1.default.dim("In case we're mistaken, please report this to us 🙏.")}`);
        }
        util_1.plusX(prismaPath);
        return prismaPath;
    }
    printDatasources() {
        if (this.datasources) {
            return JSON.stringify(this.datasources);
        }
        return '[]';
    }
    /**
     * Starts the engine, returns the url that it runs on
     */
    async start() {
        if (!this.startPromise) {
            this.startPromise = this.internalStart();
        }
        return this.startPromise;
    }
    internalStart() {
        return new Promise(async (resolve, reject) => {
            try {
                this.port = await this.getFreePort();
                const env = {
                    PRISMA_DML: this.datamodel,
                    PORT: String(this.port),
                    RUST_BACKTRACE: '1',
                    RUST_LOG: 'info',
                };
                if (this.datasources) {
                    env.OVERWRITE_DATASOURCES = this.printDatasources();
                }
                debug(env);
                debug({ cwd: this.cwd });
                const prismaPath = await this.getPrismaPath();
                this.child = child_process_1.spawn(prismaPath, [], {
                    env: Object.assign(Object.assign({}, process.env), env),
                    cwd: this.cwd,
                    stdio: ['pipe', 'pipe', 'pipe'],
                });
                this.child.stderr.on('data', msg => {
                    const data = String(msg);
                    if (data.includes('\u001b[1;94m-->\u001b[0m')) {
                        this.stderrLogs += data;
                    }
                });
                byline_1.default(this.child.stdout).on('data', msg => {
                    const data = String(msg);
                    try {
                        const json = JSON.parse(data);
                        const log = log_1.convertLog(json);
                        this.logEmitter.emit('log', log);
                    }
                    catch (e) {
                        debug(e, data);
                    }
                });
                this.child.on('exit', code => {
                    // const message = this.stderrLogs ? this.stderrLogs : this.stdoutLogs
                    if (code === 126) {
                        this.lastError = {
                            application: 'exit',
                            date: new Date(),
                            level: 'error',
                            message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong defined in the schema.prisma file.`,
                        };
                    }
                    else {
                        this.lastError = {
                            application: 'exit',
                            date: new Date(),
                            level: 'error',
                            message: (this.stderrLogs || '') + (this.stdoutLogs || '') + code,
                        };
                    }
                });
                this.child.on('error', err => {
                    reject(err);
                });
                if (this.lastError) {
                    return reject(new Engine_1.PhotonError(this.lastError));
                }
                try {
                    await this.engineReady();
                }
                catch (err) {
                    await this.child.kill();
                    throw err;
                }
                const url = `http://localhost:${this.port}`;
                this.url = url;
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * If Prisma runs, stop it
     */
    async stop() {
        await this.start();
        if (this.currentRequestPromise) {
            try {
                await this.currentRequestPromise;
            }
            catch (e) {
                //
            }
        }
        if (this.child) {
            debug(`Stopping Prisma engine`);
            this.exiting = true;
            await this.child.kill();
            delete this.child;
        }
    }
    /**
     * Use the port 0 trick to get a new port
     */
    getFreePort() {
        return new Promise((resolve, reject) => {
            const server = net_1.default.createServer(s => s.end(''));
            server.unref();
            server.on('error', reject);
            server.listen(0, () => {
                const address = server.address();
                const port = typeof address === 'string' ? parseInt(address.split(':').slice(-1)[0], 10) : address.port;
                server.close(e => {
                    if (e) {
                        reject(e);
                    }
                    resolve(port);
                });
            });
        });
    }
    /**
     * Make sure that our internal port is not conflicting with the prisma.yml's port
     * @param str config
     */
    trimPort(str) {
        return str
            .split('\n')
            .filter(l => !l.startsWith('port:'))
            .join('\n');
    }
    // TODO: Replace it with a simple tcp connection
    async engineReady() {
        let tries = 0;
        while (true) {
            if (!this.child) {
                return;
            }
            else if (this.child.killed) {
                throw new Error('Engine has died');
            }
            await new Promise(r => setTimeout(r, 50));
            if (this.lastError) {
                throw new Engine_1.PhotonError(this.lastError);
            }
            try {
                await got_1.default(`http://localhost:${this.port}/status`, {
                    timeout: 5000,
                });
                debug(`Ready after try number ${tries}`);
                this.ready = true;
                return;
            }
            catch (e) {
                debug(e.message);
                if (tries >= 100) {
                    throw e;
                }
            }
            finally {
                tries++;
            }
        }
    }
    async getDmmf() {
        const result = await got_1.default.get(this.url + '/dmmf', {
            json: true,
        });
        return result.body.data;
    }
    async request(query, typeName) {
        await this.start();
        if (!this.child) {
            throw new Error(`Engine has already been stopped`);
        }
        this.currentRequestPromise = got_1.default.post(this.url, {
            json: true,
            headers: {
                'Content-Type': 'application/json',
            },
            body: { query, variables: {} },
        });
        return this.currentRequestPromise
            .then(({ body }) => {
            const errors = body.error || body.errors;
            if (errors) {
                return this.handleErrors({
                    errors,
                    query,
                });
            }
            return body.data;
        })
            .catch(error => {
            if (this.currentRequestPromise.isCanceled && this.lastError) {
                throw new Engine_1.PhotonError(this.lastError);
            }
            if (error.code && error.code === 'ECONNRESET') {
                if (this.lastError) {
                    throw new Engine_1.PhotonError(this.lastError);
                }
                const logs = this.stderrLogs || this.stdoutLogs;
                throw new Error(logs);
            }
            if (!(error instanceof Engine_1.PhotonQueryError)) {
                return this.handleErrors({ errors: error, query });
            }
            else {
                throw error;
            }
        });
    }
    serializeErrors(errors) {
        // make the happy case beautiful
        if (Array.isArray(errors) && errors.length === 1 && errors[0].error && typeof errors[0].error === 'string') {
            return errors[0].error;
        }
        return JSON.stringify(errors, null, 2);
    }
    handleErrors({ errors, query }) {
        const stringified = errors ? this.serializeErrors(errors) : null;
        const message = stringified.length > 0 ? stringified : `Error in photon.\$\{rootField || 'query'}`;
        const isPanicked = this.stderrLogs.includes('panicked') || this.stdoutLogs.includes('panicked'); // TODO better handling
        if (isPanicked) {
            this.stop();
        }
        throw new Engine_1.PhotonQueryError(message);
    }
}
exports.NodeEngine = NodeEngine;
//# sourceMappingURL=NodeEngine.js.map