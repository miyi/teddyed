import { SchemaBuilder, NexusAcceptedTypeDef } from "./builder";
/**
 * A read-only builder api exposed to plugins in the onInstall hook which
 * proxies very limited functionality into the internal Nexus Builder.
 */
export declare type PluginBuilderLens = {
    hasType: (typeName: string) => boolean;
};
/**
 * This is the Neuxs Plugin interface that allows users to extend Nexus at
 * particular extension points. Plugins are just functions that receive hooks
 * which can then be registered upon with callbacks.
 */
export declare type PluginConfig = {
    name: string;
    onInstall?: PluginOnInstallHandler;
};
/**
 * The plugin callback to execute when onInstall lifecycle event occurs.
 * OnInstall event occurs before type walking which means inline types are not
 * visible at this point yet. `builderLens.hasType` will only return true
 * for types the user has defined top level in their app, and any types added by
 * upstream plugins.
 */
export declare type PluginOnInstallHandler = (builder: PluginBuilderLens) => {
    types: NexusAcceptedTypeDef[];
};
/**
 * The processed version of a plugin config. This lower level version has
 * defaults provided for optionals etc.
 */
export declare type InternalPluginConfig = Required<PluginConfig>;
/**
 * A plugin defines configuration which can document additional metadata options
 * for a type definition. This metadata can be used to decorate the "resolve" function
 * to provide custom functionality, such as logging, error handling, additional type
 * validation.
 *
 * You can specify options which can be defined on the schema,
 * the type or the plugin. The config from each of these will be
 * passed in during schema construction time, and used to augment the field as necessary.
 *
 * You can either return a function, with the new defintion of a resolver implementation,
 * or you can return an "enter" / "leave" pairing which will wrap the pre-execution of the
 * resolver and the "result" of the resolver, respectively.
 */
export declare function createPlugin(config: PluginConfig): PluginDef;
/**
 * A definition for a plugin. Should be passed to the `plugins: []` option
 * on makeSchema. Refer to `createPlugin` factory for full doc.
 */
export declare class PluginDef {
    readonly config: InternalPluginConfig;
    constructor(config: InternalPluginConfig);
}
/**
 * The interface used to drive plugin execution via lifecycle event triggering.
 */
declare type PluginController = {
    triggerOnInstall: () => void;
};
/**
 * This will gather the hook handlers (aka. callbacks, event handlers) a the
 * plugin has registered for and return a controller  to trigger said hooks,
 * thus controlling execution of the plugins' hook handlers.
 */
export declare function initialize(builder: SchemaBuilder, plugin: PluginDef): PluginController;
export {};
