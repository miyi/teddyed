"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var path_1 = tslib_1.__importDefault(require("path"));
var builder_1 = require("./builder");
function log(msg) {
    console.log("GraphQL Nexus: " + msg);
}
exports.log = log;
exports.isInterfaceField = function (type, fieldName) {
    return type.getInterfaces().some(function (i) { return Boolean(i.getFields()[fieldName]); });
};
// ----------------------------
/**
 *
 * Copied from graphql-js:
 *
 */
/**
 * Given an invalid input string and a list of valid options, returns a filtered
 * list of valid options sorted based on their similarity with the input.
 */
function suggestionList(input, options) {
    if (input === void 0) { input = ""; }
    if (options === void 0) { options = []; }
    var optionsByDistance = Object.create(null);
    var oLength = options.length;
    var inputThreshold = input.length / 2;
    for (var i = 0; i < oLength; i++) {
        var distance = lexicalDistance(input, options[i]);
        var threshold = Math.max(inputThreshold, options[i].length / 2, 1);
        if (distance <= threshold) {
            optionsByDistance[options[i]] = distance;
        }
    }
    return Object.keys(optionsByDistance).sort(function (a, b) {
        return optionsByDistance[a] - optionsByDistance[b];
    });
}
exports.suggestionList = suggestionList;
/**
 * Computes the lexical distance between strings A and B.
 *
 * The "distance" between two strings is given by counting the minimum number
 * of edits needed to transform string A into string B. An edit can be an
 * insertion, deletion, or substitution of a single character, or a swap of two
 * adjacent characters.
 *
 * Includes a custom alteration from Damerau-Levenshtein to treat case changes
 * as a single edit which helps identify mis-cased values with an edit distance
 * of 1.
 *
 * This distance can be useful for detecting typos in input or sorting
 */
function lexicalDistance(aStr, bStr) {
    if (aStr === bStr) {
        return 0;
    }
    var i;
    var j;
    var d = [];
    var a = aStr.toLowerCase();
    var b = bStr.toLowerCase();
    var aLength = a.length;
    var bLength = b.length; // Any case change counts as a single edit
    if (a === b) {
        return 1;
    }
    for (i = 0; i <= aLength; i++) {
        d[i] = [i];
    }
    for (j = 1; j <= bLength; j++) {
        d[0][j] = j;
    }
    for (i = 1; i <= aLength; i++) {
        for (j = 1; j <= bLength; j++) {
            var cost = a[i - 1] === b[j - 1] ? 0 : 1;
            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
        }
    }
    return d[aLength][bLength];
}
// ----------------------------
function objValues(obj) {
    return Object.keys(obj).reduce(function (result, key) {
        result.push(obj[key]);
        return result;
    }, []);
}
exports.objValues = objValues;
function mapObj(obj, mapper) {
    return Object.keys(obj).map(function (key, index) { return mapper(obj[key], key, index); });
}
exports.mapObj = mapObj;
function eachObj(obj, iter) {
    Object.keys(obj).forEach(function (name, i) { return iter(obj[name], name, i); });
}
exports.eachObj = eachObj;
exports.isObject = function (obj) {
    return obj !== null && typeof obj === "object";
};
exports.assertAbsolutePath = function (pathName, property) {
    if (!path_1.default.isAbsolute(pathName)) {
        throw new Error("Expected path for " + property + " to be an absolute path, saw " + pathName);
    }
    return pathName;
};
function groupTypes(schema) {
    var groupedTypes = {
        input: [],
        interface: [],
        object: [],
        union: [],
        enum: [],
        scalar: Array.from(graphql_1.specifiedScalarTypes),
    };
    var schemaTypeMap = schema.getTypeMap();
    Object.keys(schemaTypeMap)
        .sort()
        .forEach(function (typeName) {
        if (typeName.indexOf("__") === 0) {
            return;
        }
        var type = schema.getType(typeName);
        if (graphql_1.isObjectType(type)) {
            groupedTypes.object.push(type);
        }
        else if (graphql_1.isInputObjectType(type)) {
            groupedTypes.input.push(type);
        }
        else if (graphql_1.isScalarType(type) &&
            !graphql_1.isSpecifiedScalarType(type) &&
            !isUnknownType(type)) {
            groupedTypes.scalar.push(type);
        }
        else if (graphql_1.isUnionType(type)) {
            groupedTypes.union.push(type);
        }
        else if (graphql_1.isInterfaceType(type)) {
            groupedTypes.interface.push(type);
        }
        else if (graphql_1.isEnumType(type)) {
            groupedTypes.enum.push(type);
        }
    });
    return groupedTypes;
}
exports.groupTypes = groupTypes;
function isUnknownType(type) {
    return type.name === builder_1.UNKNOWN_TYPE_SCALAR.name;
}
exports.isUnknownType = isUnknownType;
function firstDefined() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (typeof arg !== "undefined") {
            return arg;
        }
    }
    /* istanbul ignore next */
    throw new Error("At least one of the values should be defined");
}
exports.firstDefined = firstDefined;
// eslint-disable-next-line no-redeclare
function isPromise(value) {
    return Boolean(value && typeof value.then === "function");
}
exports.isPromise = isPromise;
function relativePathTo(absolutePath, outputPath) {
    var filename = path_1.default.basename(absolutePath).replace(/(\.d)?\.ts/, "");
    var relative = path_1.default.relative(path_1.default.dirname(outputPath), path_1.default.dirname(absolutePath));
    if (relative.indexOf(".") !== 0) {
        return "./" + path_1.default.join(relative, filename);
    }
    return path_1.default.join(relative, filename);
}
exports.relativePathTo = relativePathTo;
/**
 * Calculate the venn diagram between two iterables based on reference equality
 * checks. The returned tripple contains items thusly:
 *
 *    * items only in arg 1 --> first tripple slot
 *    * items in args 1 & 2 --> second tripple slot
 *    * items only in arg 2 --> third tripple slot
 */
function venn(xs, ys) {
    var e_1, _a, e_2, _b;
    var lefts = new Set(xs);
    var boths = new Set();
    var rights = new Set(ys);
    try {
        for (var lefts_1 = tslib_1.__values(lefts), lefts_1_1 = lefts_1.next(); !lefts_1_1.done; lefts_1_1 = lefts_1.next()) {
            var l = lefts_1_1.value;
            if (rights.has(l)) {
                boths.add(l);
                lefts.delete(l);
                rights.delete(l);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lefts_1_1 && !lefts_1_1.done && (_a = lefts_1.return)) _a.call(lefts_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var rights_1 = tslib_1.__values(rights), rights_1_1 = rights_1.next(); !rights_1_1.done; rights_1_1 = rights_1.next()) {
            var r = rights_1_1.value;
            if (lefts.has(r)) {
                boths.add(r);
                lefts.delete(r);
                rights.delete(r);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (rights_1_1 && !rights_1_1.done && (_b = rights_1.return)) _b.call(rights_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return [lefts, boths, rights];
}
exports.venn = venn;
//# sourceMappingURL=utils.js.map