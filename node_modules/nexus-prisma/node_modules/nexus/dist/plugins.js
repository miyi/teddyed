"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _types_1 = require("./definitions/_types");
var utils_1 = require("./utils");
/**
 * A plugin defines configuration which can document additional metadata options
 * for a type definition. This metadata can be used to decorate the "resolve" function
 * to provide custom functionality, such as logging, error handling, additional type
 * validation.
 *
 * You can specify options which can be defined on the schema,
 * the type or the plugin. The config from each of these will be
 * passed in during schema construction time, and used to augment the field as necessary.
 *
 * You can either return a function, with the new defintion of a resolver implementation,
 * or you can return an "enter" / "leave" pairing which will wrap the pre-execution of the
 * resolver and the "result" of the resolver, respectively.
 */
function createPlugin(config) {
    validatePluginConfig(config);
    var internalConfig = tslib_1.__assign({}, configDefaults, config);
    return new PluginDef(internalConfig);
}
exports.createPlugin = createPlugin;
var configDefaults = {
    onInstall: function () { return ({ types: [] }); },
};
/**
 * A definition for a plugin. Should be passed to the `plugins: []` option
 * on makeSchema. Refer to `createPlugin` factory for full doc.
 */
var PluginDef = /** @class */ (function () {
    function PluginDef(config) {
        this.config = config;
    }
    return PluginDef;
}());
exports.PluginDef = PluginDef;
_types_1.withNexusSymbol(PluginDef, _types_1.NexusTypes.Plugin);
/**
 * This will gather the hook handlers (aka. callbacks, event handlers) a the
 * plugin has registered for and return a controller  to trigger said hooks,
 * thus controlling execution of the plugins' hook handlers.
 */
function initialize(builder, plugin) {
    var state = {
        onInstallTriggered: false,
    };
    var builderLens = {
        hasType: builder.hasType,
    };
    return {
        triggerOnInstall: function () {
            // Enforce the invariant that a lifecycle hook will only ever be called once.
            if (state.onInstallTriggered) {
                throw new Error("Multiple triggers of onInstall hook detected. This should never happen. This is an internal error.");
            }
            else {
                state.onInstallTriggered = true;
            }
            // By doing addType on the types returned by a plugin right after it has
            // done so we make it possible for downstream plugins to see types added
            // by upstream plugins.
            var hookResult;
            try {
                hookResult = plugin.config.onInstall(builderLens);
            }
            catch (error) {
                throw new Error("Plugin " + plugin.config.name + " failed on \"onInstall\" hook:\n\n" + error.stack);
            }
            validateOnInstallHookResult(plugin, hookResult);
            hookResult.types.forEach(builder.addType);
        },
    };
}
exports.initialize = initialize;
/**
 * Validate that the configuration given by a plugin is valid.
 */
function validatePluginConfig(plugin) {
    var validRequiredProps = ["name"];
    var validOptionalProps = ["onInstall"];
    var validProps = tslib_1.__spread(validRequiredProps, validOptionalProps);
    var givenProps = Object.keys(plugin);
    var printProps = function (props) {
        return tslib_1.__spread(props).join(", ");
    };
    var _a = tslib_1.__read(utils_1.venn(validRequiredProps, givenProps), 2), missingRequiredProps = _a[0];
    if (missingRequiredProps.size > 0) {
        throw new Error("Plugin \"" + plugin.name + "\" is missing required properties: " + printProps(missingRequiredProps));
    }
    var nameType = typeof plugin.name;
    if (nameType !== "string") {
        throw new Error("Plugin \"" + plugin.name + "\" is giving an invalid value for property name: expected \"string\" type, got " + nameType + " type");
    }
    if (plugin.name === "") {
        throw new Error("Plugin \"" + plugin.name + "\" is giving an invalid value for property name: empty string");
    }
    var _b = tslib_1.__read(utils_1.venn(validProps, givenProps), 3), invalidGivenProps = _b[2];
    if (invalidGivenProps.size > 0) {
        throw new Error("Plugin \"" + plugin.name + "\" is giving unexpected properties: " + printProps(invalidGivenProps));
    }
    if (plugin.onInstall) {
        var onInstallType = typeof plugin.onInstall;
        if (onInstallType !== "function") {
            throw new Error("Plugin \"" + plugin.name + "\" is giving an invalid value for onInstall hook: expected \"function\" type, got " + onInstallType + " type");
        }
    }
}
/**
 * Validate that the data returned from a plugin from the `onInstall` hook is valid.
 */
function validateOnInstallHookResult(plugin, hookResult) {
    if (hookResult === null ||
        typeof hookResult !== "object" ||
        !Array.isArray(hookResult.types)) {
        throw new Error("Plugin \"" + plugin.config.name + "\" returned invalid data for \"onInstall\" hook:\n\nexpected structure:\n\n  { types: NexusAcceptedTypeDef[] }\n\ngot:\n\n  " + hookResult);
    }
    // TODO we should validate that the array members all fall under NexusAcceptedTypeDef
}
//# sourceMappingURL=plugins.js.map