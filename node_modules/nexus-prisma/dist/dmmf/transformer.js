"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function transform(document) {
    return {
        datamodel: transformDatamodel(document.datamodel),
        mappings: document.mappings,
        schema: transformSchema(document.schema),
    };
}
exports.transform = transform;
function transformDatamodel(datamodel) {
    return {
        enums: datamodel.enums,
        models: datamodel.models.map(model => (Object.assign(Object.assign({}, model), { fields: model.fields.map(field => (Object.assign(Object.assign({}, field), { kind: field.kind === 'object' ? 'relation' : field.kind }))) }))),
    };
}
function transformSchema(schema) {
    return {
        enums: schema.enums,
        inputTypes: schema.inputTypes.map(transformInputType),
        outputTypes: schema.outputTypes.map(o => (Object.assign(Object.assign({}, o), { fields: o.fields.map(f => (Object.assign(Object.assign({}, f), { args: f.args.map(transformArg), outputType: Object.assign(Object.assign({}, f.outputType), { type: getReturnTypeName(f.outputType.type) }) }))) }))),
    };
}
/**
 * Conversion from a Photon arg type to a GraphQL arg type using
 * heuristics. A conversion is needed becuase GraphQL does not
 * support union types on args, but Photon does.
 */
function transformArg(arg) {
    // FIXME: *Enum*Filter are currently empty
    let inputType = arg.inputType.some(a => a.kind === 'enum')
        ? arg.inputType[0]
        : arg.inputType.find(a => a.kind === 'object');
    if (!inputType) {
        inputType = arg.inputType[0];
    }
    return {
        name: arg.name,
        inputType: Object.assign(Object.assign({}, inputType), { type: getReturnTypeName(inputType.type) }),
        // FIXME Why?
        isRelationFilter: undefined,
    };
}
function transformInputType(inputType) {
    return Object.assign(Object.assign({}, inputType), { fields: inputType.fields.map(transformArg) });
}
/**
 * Make the "return type" property type always be a string. In Photon
 * it is allowed to be a nested structured object but we want only the
 * reference-by-name form.
 *
 */
//
// TODO _why_ is the dmmf like this?
//
// FIXME `any` type becuase this is used by both outputType and inputType
// and there is currently no generic capturing both ideas.
//
function getReturnTypeName(type) {
    if (typeof type === 'string') {
        return type;
    }
    return type.name;
}
//# sourceMappingURL=transformer.js.map