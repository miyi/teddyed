import * as Nexus from 'nexus';
import { DynamicOutputPropertyDef } from 'nexus/dist/dynamicProperty';
import * as DMMF from './dmmf';
import { ArgsNamingStrategy, FieldNamingStrategy } from './naming-strategies';
import { Publisher } from './publisher';
interface FieldPublisherConfig {
    alias?: string;
    type?: Nexus.core.AllOutputTypes;
    pagination?: boolean | Record<string, boolean>;
    filtering?: boolean | Record<string, boolean>;
    ordering?: boolean | Record<string, boolean>;
}
declare type FieldPublisher = (opts?: FieldPublisherConfig) => PublisherMethods;
declare type PublisherMethods = Record<string, FieldPublisher>;
export interface Options {
    types: any;
    photon?: (ctx: Nexus.core.GetGen<'context'>) => any;
    shouldGenerateArtifacts?: boolean;
    inputs?: {
        photon?: string;
    };
    outputs?: {
        typegen?: string;
    };
}
export interface InternalOptions extends Options {
    dmmf?: DMMF.DMMF;
}
/**
 * Create nexus type definitions and resolvers particular to your prisma
 * schema that extend the Nexus DSL with e.g. t.model and t.crud. Example
 * effect in practice:
 *
 *    objectType({
 *      name: 'User',
 *      definition(t) {
 *        t.model.id()
 *        t.model.email()
 *      }
 *    })
 *
 *    queryType({
 *      definition (t) {
 *        t.crud.user()
 *        t.crud.users({ filtering: true, ordering: true })
 *      }
 *    })
 *
 * You must ensure the photon client has been generated prior as
 * it provides a data representation of the available models and CRUD
 * operations against them.
 *
 * Typically you will forward the type defs returned
 * here to Nexus' makeSchema function.
 *
 * Additionally, typegen will be run synchronously upon construction by default
 * if NODE_ENV is undefined or "development". Typegen can be explicitly enabled or
 * disabled via the shouldGenerateArtifacts option. This mirrors Nexus'
 * own typegen approach. This system will change once Nexus Plugins are
 * released.
 */
export declare function build(options: Options): (DynamicOutputPropertyDef<"crud"> | DynamicOutputPropertyDef<"model">)[];
export interface CustomInputArg {
    arg: DMMF.Data.SchemaArg;
    type: DMMF.Data.InputType | DMMF.Data.Enum | {
        name: string;
    };
}
export declare class SchemaBuilder {
    protected options: InternalOptions;
    protected readonly dmmf: DMMF.DMMF;
    protected argsNamingStrategy: ArgsNamingStrategy;
    protected fieldNamingStrategy: FieldNamingStrategy;
    protected getPhoton: any;
    protected publisher: Publisher;
    constructor(options: InternalOptions);
    /**
     * The build entrypoint, bringing together sub-builders.
     */
    build(): (DynamicOutputPropertyDef<"crud"> | DynamicOutputPropertyDef<"model">)[];
    /**
     * Build `t.crud` dynamic output property
     */
    protected buildCRUD(): DynamicOutputPropertyDef<'crud'>;
    /**
     * Build the `t.model` dynamic output property.
     */
    protected buildModel(): DynamicOutputPropertyDef<"model">;
    protected internalBuildModel(typeName: string, t: Nexus.core.OutputDefinitionBlock<any>): Record<string, FieldPublisher>;
    protected buildArgsFromField(typeName: string, operationName: keyof DMMF.Data.Mapping | null, field: DMMF.Data.SchemaField, resolvedConfig: FieldPublisherConfig): Nexus.core.ArgsRecord;
    protected argsFromQueryOrModelField(typeName: string, dmmfField: DMMF.Data.SchemaField, resolvedConfig: FieldPublisherConfig): CustomInputArg[];
    /**
     * This handles "tailored field feature publishing".
     *
     * With tailord field feature publishing, users can specify that only
     * some fields of the PSL model are exposed under the given field feature.
     * For example, in the following...
     *
     *    t.model.friends({ filtering: { firstName: true, location: true } })
  
     * ...the field feature is "filtering" and the user has tailored it so
     * that only "firstName" and "location" of the field's type (e.g. "User")
     * are exposed to filtering on this field. So the resulting GQL TypeDef
     * would look something like:
     *
     *    ...
     *   friends(where: { firstName: ..., location: ..., }): [User]
     *   ...
     *
     */
    protected handleInputObjectCustomization(fieldWhitelist: Record<string, boolean> | boolean, inputTypeName: string, fieldName: string, graphQLTypeName: string): DMMF.Data.InputType;
}
export {};
//# sourceMappingURL=builder.d.ts.map