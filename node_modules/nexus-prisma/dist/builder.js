"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Nexus = __importStar(require("nexus"));
const path = __importStar(require("path"));
const DMMF = __importStar(require("./dmmf"));
const GraphQL = __importStar(require("./graphql"));
const mapping_1 = require("./mapping");
const naming_strategies_1 = require("./naming-strategies");
const publisher_1 = require("./publisher");
const Typegen = __importStar(require("./typegen"));
const utils_1 = require("./utils");
/**
 * When dealing with list types we rely on the list type zero value (empty-list)
 * to represet the idea of null.
 *
 * For Photon's part, it will never return null for list type fields nor will it
 * ever return null value list members.
 */
const dmmfListFieldTypeToNexus = (fieldType) => {
    return fieldType.isList
        ? {
            list: [true],
            nullable: false,
        }
        : {
            nullable: !fieldType.isRequired,
        };
};
/**
 * Create nexus type definitions and resolvers particular to your prisma
 * schema that extend the Nexus DSL with e.g. t.model and t.crud. Example
 * effect in practice:
 *
 *    objectType({
 *      name: 'User',
 *      definition(t) {
 *        t.model.id()
 *        t.model.email()
 *      }
 *    })
 *
 *    queryType({
 *      definition (t) {
 *        t.crud.user()
 *        t.crud.users({ filtering: true, ordering: true })
 *      }
 *    })
 *
 * You must ensure the photon client has been generated prior as
 * it provides a data representation of the available models and CRUD
 * operations against them.
 *
 * Typically you will forward the type defs returned
 * here to Nexus' makeSchema function.
 *
 * Additionally, typegen will be run synchronously upon construction by default
 * if NODE_ENV is undefined or "development". Typegen can be explicitly enabled or
 * disabled via the shouldGenerateArtifacts option. This mirrors Nexus'
 * own typegen approach. This system will change once Nexus Plugins are
 * released.
 */
function build(options) {
    const builder = new SchemaBuilder(options);
    return builder.build();
}
exports.build = build;
// The @types default is based on the priviledge given to such
// packages by TypeScript. For details refer to https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types
let defaultTypegenPath;
if (process.env.NEXUS_PRISMA_TYPEGEN_PATH) {
    defaultTypegenPath = process.env.NEXUS_PRISMA_TYPEGEN_PATH;
}
else if (process.env.NEXUS_PRISMA_LINK) {
    defaultTypegenPath = path.join(process.cwd(), 'node_modules/@types/nexus-prisma-typegen/index.d.ts');
}
else {
    defaultTypegenPath = path.join(__dirname, '../../@types/nexus-prisma-typegen/index.d.ts');
}
// Note Default should be updated once resolved:
// https://github.com/prisma/photonjs/issues/88
let defaultPhotonPath;
if (process.env.NEXUS_PRISMA_PHOTON_PATH) {
    defaultPhotonPath = process.env.NEXUS_PRISMA_PHOTON_PATH;
}
else if (process.env.NEXUS_PRISMA_LINK) {
    defaultPhotonPath = path.join(process.cwd(), '/node_modules/@generated/photon');
}
else {
    defaultPhotonPath = '@generated/photon';
}
// NOTE This will be repalced by Nexus plugins once typegen integration is available.
const shouldGenerateArtifacts = process.env.NEXUS_SHOULD_GENERATE_ARTIFACTS === 'true'
    ? true
    : process.env.NEXUS_SHOULD_GENERATE_ARTIFACTS === 'false'
        ? false
        : Boolean(!process.env.NODE_ENV || process.env.NODE_ENV === 'development');
const defaultOptions = {
    shouldGenerateArtifacts,
    photon: (ctx) => ctx.photon,
    inputs: {
        photon: defaultPhotonPath,
    },
    outputs: {
        typegen: defaultTypegenPath,
    },
};
class SchemaBuilder {
    constructor(options) {
        this.options = options;
        const config = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), { inputs: Object.assign(Object.assign({}, defaultOptions.inputs), options.inputs), outputs: Object.assign(Object.assign({}, defaultOptions.outputs), options.outputs) });
        this.dmmf = options.dmmf || DMMF.get(config.inputs.photon);
        this.publisher = new publisher_1.Publisher(this.dmmf, utils_1.unwrapTypes(config.types));
        this.argsNamingStrategy = naming_strategies_1.defaultArgsNamingStrategy;
        this.fieldNamingStrategy = naming_strategies_1.defaultFieldNamingStrategy;
        this.getPhoton = config.photon;
        if (config.shouldGenerateArtifacts) {
            Typegen.generateSync({
                photonPath: config.inputs.photon,
                typegenPath: config.outputs.typegen,
            });
        }
    }
    /**
     * The build entrypoint, bringing together sub-builders.
     */
    build() {
        return [this.buildCRUD(), this.buildModel()];
    }
    /**
     * Build `t.crud` dynamic output property
     */
    buildCRUD() {
        return Nexus.dynamicOutputProperty({
            name: 'crud',
            typeDefinition: `: NexusPrisma<TypeName, 'crud'>`,
            // FIXME
            // Nexus should improve the type of typeName to be AllOutputTypes
            factory: ({ typeDef: t, typeName }) => {
                if (typeName === GraphQL.rootNames.Subscription) {
                    // TODO Lets put a GitHub issue link in this error message
                    throw new Error(`t.crud is not yet supported on the 'Subscription' type.`);
                }
                if (typeName !== GraphQL.rootNames.Query &&
                    typeName !== GraphQL.rootNames.Mutation) {
                    throw new Error(`t.crud can only be used on GraphQL root types 'Query' & 'Mutation' but was used on '${typeName}'. Please use 't.model' instead`);
                }
                return mapping_1.getCrudMappedFields(typeName, this.dmmf).reduce((crud, mappedField) => {
                    const fieldPublisher = givenConfig => {
                        const resolvedConfig = Object.assign({ pagination: true, type: mappedField.field.outputType.type }, givenConfig);
                        const gqlFieldName = resolvedConfig.alias || mappedField.field.name;
                        t.field(gqlFieldName, Object.assign(Object.assign({ type: this.publisher.outputType(resolvedConfig.type, mappedField.field) }, dmmfListFieldTypeToNexus(mappedField.field.outputType)), { args: this.buildArgsFromField(typeName, mappedField.operation, mappedField.field, resolvedConfig), resolve: (_parent, args, ctx) => {
                                const photon = this.getPhoton(ctx);
                                utils_1.assertPhotonInContext(photon);
                                return photon[mappedField.photonAccessor][mappedField.operation](args);
                            } }));
                        return crud;
                    };
                    crud[mappedField.field.name] = fieldPublisher;
                    return crud;
                }, {});
            },
        });
    }
    /**
     * Build the `t.model` dynamic output property.
     */
    buildModel() {
        return Nexus.dynamicOutputProperty({
            name: 'model',
            typeDefinition: `: NexusPrisma<TypeName, 'model'>`,
            /**
             * This factory implements what .model will actually be.
             *
             * If the user's GQL typedef name matches a PSL model name,
             * then we infer that the user is trying to create a mapping
             * between them. This is the implicit mapping case.
             *
             * Otherwise we need the user to specify what PSL model
             * their GQL object maps to. This is the explicit mapping case.
             *
             * In the implicit case we eagerly do the .model implementation,
             * but in the explicit case we return a function in order that the
             * user may specify the mapping.
             *
             * Examples:
             *
             *    // Given PSL that contains:
             *
             *    model User {
             *      id    String @unique @id @default(uuid())
             *      email String @unique
             *    }
             *
             *    // Example of implicit mapping
             *
             *    objectType({
             *      name: 'User',
             *      definition(t) {
             *        t.model.id()
             *        t.model.email()
             *      }
             *    })
             *
             *    // Example of explicit mapping
             *
             *    objectType({
             *      name: 'Customer',
             *      definition(t) {
             *        t.model('User').id()
             *        t.model('User').email()
             *      }
             *    })
             *
             */
            factory: ({ typeDef, typeName }) => this.dmmf.hasModel(typeName)
                ? this.internalBuildModel(typeName, typeDef)
                : (modelName) => this.internalBuildModel(modelName, typeDef),
        });
    }
    internalBuildModel(typeName, t) {
        const model = this.dmmf.getModelOrThrow(typeName);
        const outputType = this.dmmf.getOutputType(model.name);
        const publishers = outputType.fields.reduce((acc, field) => {
            const fieldPublisher = givenConfig => {
                const resolvedConfig = Object.assign({ pagination: true, type: field.outputType.type }, givenConfig);
                const fieldName = resolvedConfig.alias || field.name;
                const type = resolvedConfig.type || field.outputType.type;
                const fieldOpts = Object.assign(Object.assign({ type: this.publisher.outputType(type, field) }, dmmfListFieldTypeToNexus(field.outputType)), { args: this.buildArgsFromField(typeName, null, field, resolvedConfig) });
                // Rely on default resolvers for scalars and enums
                if (field.outputType.kind === 'object') {
                    const mapping = this.dmmf.getMapping(typeName);
                    fieldOpts.resolve = (root, args, ctx) => {
                        const photon = this.getPhoton(ctx);
                        utils_1.assertPhotonInContext(photon);
                        return photon[mapping.plural]['findOne']({ where: { id: root.id } })[field.name](args);
                    };
                }
                t.field(fieldName, fieldOpts);
                return publishers;
            };
            acc[field.name] = fieldPublisher;
            return acc;
        }, {});
        return publishers;
    }
    buildArgsFromField(typeName, operationName, field, resolvedConfig) {
        let args = [];
        if (typeName === 'Mutation' || operationName === 'findOne') {
            args = field.args.map(arg => ({
                arg,
                type: this.dmmf.getInputType(arg.inputType.type),
            }));
        }
        else {
            args = this.argsFromQueryOrModelField(typeName, field, resolvedConfig);
        }
        return args.reduce((acc, customArg) => {
            acc[customArg.arg.name] = this.publisher.inputType(customArg); //FIXME
            return acc;
        }, {});
    }
    argsFromQueryOrModelField(typeName, dmmfField, resolvedConfig) {
        let args = [];
        if (resolvedConfig.filtering) {
            const inputObjectTypeDefName = `${dmmfField.outputType.type}WhereInput`;
            const whereArg = dmmfField.args.find(arg => arg.inputType.type === inputObjectTypeDefName && arg.name === 'where');
            if (!whereArg) {
                throw new Error(`Could not find filtering argument for ${typeName}.${dmmfField.name}`);
            }
            args.push({
                arg: whereArg,
                type: this.handleInputObjectCustomization(resolvedConfig.filtering, inputObjectTypeDefName, dmmfField.name, typeName),
            });
        }
        if (resolvedConfig.ordering) {
            const orderByTypeName = `${dmmfField.outputType.type}OrderByInput`;
            const orderByArg = dmmfField.args.find(arg => arg.inputType.type === orderByTypeName && arg.name === 'orderBy');
            if (!orderByArg) {
                throw new Error(`Could not find ordering argument for ${typeName}.${dmmfField.name}`);
            }
            args.push({
                arg: orderByArg,
                type: this.handleInputObjectCustomization(resolvedConfig.ordering, orderByTypeName, dmmfField.name, typeName),
            });
        }
        if (resolvedConfig.pagination) {
            const paginationKeys = ['first', 'last', 'before', 'after', 'skip'];
            const paginationsArgs = resolvedConfig.pagination === true
                ? dmmfField.args.filter(a => paginationKeys.includes(a.name))
                : dmmfField.args.filter(arg => resolvedConfig.pagination[arg.name] === true);
            args.push(...paginationsArgs.map(a => ({
                arg: a,
                type: { name: a.inputType.type },
            })));
        }
        return args;
    }
    /**
     * This handles "tailored field feature publishing".
     *
     * With tailord field feature publishing, users can specify that only
     * some fields of the PSL model are exposed under the given field feature.
     * For example, in the following...
     *
     *    t.model.friends({ filtering: { firstName: true, location: true } })
  
     * ...the field feature is "filtering" and the user has tailored it so
     * that only "firstName" and "location" of the field's type (e.g. "User")
     * are exposed to filtering on this field. So the resulting GQL TypeDef
     * would look something like:
     *
     *    ...
     *   friends(where: { firstName: ..., location: ..., }): [User]
     *   ...
     *
     */
    handleInputObjectCustomization(fieldWhitelist, inputTypeName, fieldName, graphQLTypeName) {
        const photonObject = this.dmmf.getInputType(inputTypeName);
        // If the publishing for this field feature (filtering, ordering, ...)
        // has not been tailored then we may simply pass through the backing
        // version as-is.
        //
        if (fieldWhitelist === true) {
            return photonObject;
        }
        // REFACTOR use an intersection function
        const whitelistedFieldNames = Object.keys(fieldWhitelist);
        const userExposedObjectFields = photonObject.fields.filter(field => whitelistedFieldNames.includes(field.name));
        const uniqueName = photonObject.isWhereType
            ? this.argsNamingStrategy.whereInput(graphQLTypeName, fieldName)
            : this.argsNamingStrategy.orderByInput(graphQLTypeName, fieldName);
        return Object.assign(Object.assign({}, photonObject), { name: uniqueName, fields: userExposedObjectFields });
    }
}
exports.SchemaBuilder = SchemaBuilder;
//# sourceMappingURL=builder.js.map