"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Nexus = __importStar(require("nexus"));
const graphql_1 = require("./graphql");
const utils_1 = require("./utils");
class Publisher {
    constructor(dmmf, publishedTypesMap) {
        this.dmmf = dmmf;
        this.publishedTypesMap = publishedTypesMap;
    }
    inputType(customArg) {
        const typeName = customArg.type.name;
        // If type is already published, just reference it
        if (this.isPublished(typeName)) {
            return Nexus.arg(utils_1.dmmfFieldToNexusFieldConfig(Object.assign(Object.assign({}, customArg.arg.inputType), { type: customArg.type.name })));
        }
        if (customArg.arg.inputType.kind === 'scalar') {
            return this.publishScalar(customArg.type.name);
        }
        if (customArg.arg.inputType.kind === 'enum') {
            return this.publishEnum(customArg.type.name);
        }
        const inputType = customArg.type;
        return this.publishInputObjectType(inputType);
    }
    // Return type of 'any' to prevent a type mismatch with `type` property of nexus
    outputType(outputTypeName, field) {
        /**
         * Rules:
         * - If outputTypeName is already published
         * - Or if outputTypeName matches a prisma model name
         * - Then simply reference the type. Types that matches a prisma model name should be published manually by users.
         */
        if (this.isPublished(outputTypeName) ||
            this.dmmf.hasModel(outputTypeName)) {
            return outputTypeName;
        }
        // If output object type, just reference the type
        if (field.outputType.kind === 'object') {
            return this.publishObject(outputTypeName);
        }
        if (this.dmmf.hasEnumType(outputTypeName)) {
            return this.publishEnum(outputTypeName);
        }
        if (field.outputType.kind === 'scalar') {
            return this.publishScalar(outputTypeName);
        }
        return outputTypeName;
    }
    publishObject(name) {
        const dmmfObject = this.dmmf.getOutputType(name);
        this.markTypeAsPublished(name);
        return Nexus.objectType({
            name,
            definition: t => {
                for (const field of dmmfObject.fields) {
                    t.field(field.name, utils_1.dmmfFieldToNexusFieldConfig(field.outputType));
                }
            },
        });
    }
    publishScalar(typeName) {
        if (graphql_1.scalarsNameValues.includes(typeName)) {
            return typeName;
        }
        this.markTypeAsPublished(typeName);
        return Nexus.scalarType({
            name: typeName,
            serialize(value) {
                return value;
            },
        });
    }
    publishEnum(typeName) {
        const dmmfEnum = this.dmmf.getEnumType(typeName);
        this.markTypeAsPublished(typeName);
        return Nexus.enumType({
            name: typeName,
            members: dmmfEnum.values,
        });
    }
    publishInputObjectType(inputType) {
        this.markTypeAsPublished(inputType.name);
        return Nexus.inputObjectType({
            name: inputType.name,
            definition: t => {
                const [scalarFields, objectFields] = utils_1.partition(inputType.fields, f => f.inputType.kind === 'scalar');
                const remappedObjectFields = objectFields.map(field => (Object.assign(Object.assign({}, field), { inputType: Object.assign(Object.assign({}, field.inputType), { type: this.isPublished(field.inputType.type)
                            ? // Simply reference the field input type if it's already been visited, otherwise create it
                                field.inputType.type
                            : this.inputType({
                                arg: field,
                                type: this.getTypeFromArg(field),
                            }) }) })));
                [...scalarFields, ...remappedObjectFields].forEach(field => {
                    t.field(field.name, utils_1.dmmfFieldToNexusFieldConfig(field.inputType));
                });
            },
        });
    }
    getTypeFromArg(arg) {
        const kindToType = {
            scalar: (typeName) => ({
                name: this.dmmf.getOutputType(typeName).name,
            }),
            enum: (typeName) => this.dmmf.getEnumType(typeName),
            object: (typeName) => this.dmmf.getInputType(typeName),
        };
        return kindToType[arg.inputType.kind](arg.inputType.type);
    }
    isPublished(typeName) {
        return this.publishedTypesMap[typeName];
    }
    markTypeAsPublished(typeName) {
        this.publishedTypesMap[typeName] = true;
    }
}
exports.Publisher = Publisher;
//# sourceMappingURL=publisher.js.map