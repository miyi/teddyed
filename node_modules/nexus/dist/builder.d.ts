import { GraphQLEnumType, GraphQLFieldConfig, GraphQLFieldConfigArgumentMap, GraphQLFieldConfigMap, GraphQLFieldResolver, GraphQLInputFieldConfig, GraphQLInputFieldConfigMap, GraphQLInputObjectType, GraphQLInputType, GraphQLInterfaceType, GraphQLNamedType, GraphQLObjectType, GraphQLOutputType, GraphQLScalarType, GraphQLSchema, GraphQLUnionType, GraphQLField } from "graphql";
import { NexusArgConfig, ArgsRecord } from "./definitions/args";
import { InputDefinitionBlock, NexusInputFieldDef, NexusOutputFieldDef, OutputDefinitionBlock } from "./definitions/definitionBlocks";
import { EnumTypeConfig } from "./definitions/enumType";
import { NexusExtendTypeConfig, NexusExtendTypeDef } from "./definitions/extendType";
import { NexusInputObjectTypeConfig } from "./definitions/inputObjectType";
import { NexusInterfaceTypeConfig, NexusInterfaceTypeDef } from "./definitions/interfaceType";
import { NexusObjectTypeConfig, NexusObjectTypeDef, ObjectDefinitionBlock } from "./definitions/objectType";
import { NexusScalarTypeConfig } from "./definitions/scalarType";
import { NexusUnionTypeConfig, UnionMembers } from "./definitions/unionType";
import { AllNexusInputTypeDefs, AllNexusNamedTypeDefs, NexusWrappedType, AllNexusOutputTypeDefs } from "./definitions/wrapping";
import { GraphQLPossibleInputs, GraphQLPossibleOutputs, NonNullConfig, RootTypings, MissingType } from "./definitions/_types";
import { TypegenAutoConfigOptions } from "./typegenAutoConfig";
import { TypegenFormatFn } from "./typegenFormatPrettier";
import { GetGen, AuthorizeResolver } from "./typegenTypeHelpers";
import { NexusExtendInputTypeDef, NexusExtendInputTypeConfig } from "./definitions/extendInputType";
import { DynamicInputMethodDef, DynamicOutputMethodDef } from "./dynamicMethod";
import { DynamicOutputPropertyDef } from "./dynamicProperty";
export declare type Maybe<T> = T | null;
declare type NexusShapedOutput = {
    name: string;
    definition: (t: ObjectDefinitionBlock<string>) => void;
};
declare type NexusShapedInput = {
    name: string;
    definition: (t: InputDefinitionBlock<string>) => void;
};
export declare const UNKNOWN_TYPE_SCALAR: GraphQLScalarType & {
    extensions: import("./definitions/decorateType").NexusTypeExtensions;
};
export interface BuilderConfig {
    /**
     * Generated artifact settings. Set to false to disable all.
     * Set to true to enable all and use default paths. Leave
     * undefined for default behaviour of each artifact.
     */
    outputs?: boolean | {
        /**
         * TypeScript declaration file generation settings. This file
         * contains types reflected off your source code. It is how
         * Nexus imbues dynamic code with static guarnatees.
         *
         * Defaults to being enabled when `process.env.NODE_ENV !== "production"`.
         * Set to true to enable and emit into default path (see below).
         * Set to false to disable. Set to a string to specify absolute path.
         *
         * The default path is node_modules/@types/__nexus-typegen__core/index.d.ts.
         * This is chosen becuase TypeScript will pick it up without
         * any configuration needed by you. For more details about the @types
         * system refer to https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types
         */
        typegen?: boolean | string;
        /**
         * GraphQL SDL generation settings. This file is not necessary but
         * may be nice for teams wishing to review SDL in pull-requests or
         * just generally transitioning from a schema-first workflow.
         *
         * Defaults to false (disabled). Set to true to enable and emit into
         * default path (current working directory). Set to a string to specify
         * absolute path.
         */
        schema?: boolean | string;
    };
    /**
     * Whether the schema & types are generated when the server
     * starts. Default is !process.env.NODE_ENV || process.env.NODE_ENV === "development"
     */
    shouldGenerateArtifacts?: boolean;
    /**
     * Automatically configure type resolution for the TypeScript
     * representations of the associated types.
     *
     * Alias for typegenConfig: typegenAutoConfig(options)
     */
    typegenAutoConfig?: TypegenAutoConfigOptions;
    /**
     * A configuration function for advanced cases where
     * more control over the `TypegenInfo` is needed.
     */
    typegenConfig?: (schema: GraphQLSchema, outputPath: string) => TypegenInfo | PromiseLike<TypegenInfo>;
    /**
     * Either an absolute path to a .prettierrc file, or an object
     * with relevant Prettier rules to be used on the generated output
     */
    prettierConfig?: string | object;
    /**
     * Manually apply a formatter to the generated content before saving,
     * see the `prettierConfig` option if you want to use Prettier.
     */
    formatTypegen?: TypegenFormatFn;
    /**
     * Configures the default "nonNullDefaults" for the entire schema the type.
     * Read more about how nexus handles nullability
     */
    nonNullDefaults?: NonNullConfig;
}
export interface SchemaConfig extends BuilderConfig {
    /**
     * All of the GraphQL types. This is an any for simplicity of developer experience,
     * if it's an object we get the values, if it's an array we flatten out the
     * valid types, ignoring invalid ones.
     */
    types: any;
}
export interface TypegenInfo {
    /**
     * Headers attached to the generate type output
     */
    headers: string[];
    /**
     * All imports for the backing types / context
     */
    imports: string[];
    /**
     * A map of all GraphQL types and what TypeScript types they should
     * be represented by.
     */
    backingTypeMap: {
        [K in GetGen<"objectNames">]?: string;
    };
    /**
     * The type of the context for the resolvers
     */
    contextType?: string;
}
/**
 * The resolved builder config wherein optional fields have been
 * given their fallbacks, etc.
 */
export interface InternalBuilderConfig extends BuilderConfig {
    outputs: {
        schema: false | string;
        typegen: false | string;
    };
}
export declare function resolveBuilderConfig(config: BuilderConfig): InternalBuilderConfig;
export interface InternalSchemaConfig extends InternalBuilderConfig {
    types: any;
}
export declare type TypeToWalk = {
    type: "named";
    value: GraphQLNamedType;
} | {
    type: "input";
    value: NexusShapedInput;
} | {
    type: "object";
    value: NexusShapedOutput;
} | {
    type: "interface";
    value: NexusInterfaceTypeConfig<any>;
};
export declare type DynamicInputFields = Record<string, DynamicInputMethodDef<string> | string>;
export declare type DynamicOutputFields = Record<string, DynamicOutputMethodDef<string> | string>;
export declare type DynamicOutputProperties = Record<string, DynamicOutputPropertyDef<string>>;
/**
 * Builds all of the types, properly accounts for any using "mix".
 * Since the enum types are resolved synchronously, these need to guard for
 * circular references at this step, while fields will guard for it during lazy evaluation.
 */
export declare class SchemaBuilder {
    protected config: BuilderConfig;
    /**
     * Used to check for circular references.
     */
    protected buildingTypes: Set<unknown>;
    /**
     * The "final type" map contains all types as they are built.
     */
    protected finalTypeMap: Record<string, GraphQLNamedType>;
    /**
     * The "defined type" map keeps track of all of the types that were
     * defined directly as `GraphQL*Type` objects, so we don't accidentally
     * overwrite any.
     */
    protected definedTypeMap: Record<string, GraphQLNamedType>;
    /**
     * The "pending type" map keeps track of all types that were defined w/
     * GraphQL Nexus and haven't been processed into concrete types yet.
     */
    protected pendingTypeMap: Record<string, AllNexusNamedTypeDefs>;
    /**
     * All "extensions" to types (adding fields on types from many locations)
     */
    protected typeExtensionMap: Record<string, NexusExtendTypeConfig<string>[] | null>;
    /**
     * All "extensions" to input types (adding fields on types from many locations)
     */
    protected inputTypeExtensionMap: Record<string, NexusExtendInputTypeConfig<string>[] | null>;
    /**
     * Configures the root-level nonNullDefaults defaults
     */
    protected nonNullDefaults: NonNullConfig;
    /**
     * Add dynamic input fields
     */
    protected dynamicInputFields: DynamicInputFields;
    /**
     * Add dynamic output fields
     */
    protected dynamicOutputFields: DynamicOutputFields;
    /**
     * Add dynamic output properties
     */
    protected dynamicOutputProperties: DynamicOutputProperties;
    /**
     * All types that need to be traversed for children types
     */
    protected typesToWalk: TypeToWalk[];
    /**
     * Root type mapping information annotated on the type definitions
     */
    protected rootTypings: RootTypings;
    /**
     * Array of missing types
     */
    protected missingTypes: Record<string, MissingType>;
    /**
     * Whether we've called `getFinalTypeMap` or not
     */
    protected finalized: boolean;
    constructor(config: BuilderConfig);
    getConfig(): BuilderConfig;
    /**
     * Add type takes a Nexus type, or a GraphQL type and pulls
     * it into an internal "type registry". It also does an initial pass
     * on any types that are referenced on the "types" field and pulls
     * those in too, so you can define types anonymously, without
     * exporting them.
     *
     * @param typeDef
     */
    addType(typeDef: AllNexusNamedTypeDefs | NexusExtendInputTypeDef<string> | NexusExtendTypeDef<string> | GraphQLNamedType | DynamicInputMethodDef<string> | DynamicOutputMethodDef<string> | DynamicOutputPropertyDef<string>): void;
    walkTypes(): void;
    getFinalTypeMap(): BuildTypes<any>;
    buildInputObjectType(config: NexusInputObjectTypeConfig<any>): GraphQLInputObjectType;
    buildObjectType(config: NexusObjectTypeConfig<any>): GraphQLObjectType<any, any, {
        [key: string]: any;
    }>;
    buildInterfaceType(config: NexusInterfaceTypeConfig<any>): GraphQLInterfaceType;
    buildEnumType(config: EnumTypeConfig<any>): GraphQLEnumType;
    buildUnionType(config: NexusUnionTypeConfig<any>): GraphQLUnionType;
    buildScalarType(config: NexusScalarTypeConfig<string>): GraphQLScalarType;
    protected finalize<T extends GraphQLNamedType>(type: T): T;
    protected missingType(typeName: string, fromObject?: boolean): GraphQLNamedType;
    protected buildUnionMembers(unionName: string, members: UnionMembers | undefined): GraphQLObjectType<any, any, {
        [key: string]: any;
    }>[];
    protected buildObjectFields(fields: NexusOutputFieldDef[], typeConfig: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any>, intoObject: GraphQLFieldConfigMap<any, any>, forInterface?: boolean): GraphQLFieldConfigMap<any, any>;
    protected buildInputObjectFields(fields: NexusInputFieldDef[], typeConfig: NexusInputObjectTypeConfig<string>): GraphQLInputFieldConfigMap;
    protected buildObjectField(fieldConfig: NexusOutputFieldDef, typeConfig: NexusObjectTypeConfig<string> | NexusInterfaceTypeConfig<string>, forInterface?: boolean): GraphQLFieldConfig<any, any>;
    protected buildInputObjectField(field: NexusInputFieldDef, typeConfig: NexusInputObjectTypeConfig<any>): GraphQLInputFieldConfig;
    protected buildArgs(args: ArgsRecord, typeConfig: NexusObjectTypeConfig<string> | NexusInterfaceTypeConfig<string>): GraphQLFieldConfigArgumentMap;
    protected inputNonNull(typeDef: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any> | NexusInputObjectTypeConfig<any>, field: NexusInputFieldDef | NexusArgConfig<any>): boolean;
    protected outputNonNull(typeDef: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any>, field: NexusOutputFieldDef): boolean;
    protected decorateType<T extends GraphQLNamedType>(type: T, list: null | undefined | true | boolean[], isNonNull: boolean): T;
    protected decorateList<T extends GraphQLOutputType | GraphQLInputType>(type: T, list: true | boolean[]): T;
    protected getInterface(name: string | NexusInterfaceTypeDef<string>): GraphQLInterfaceType;
    protected getInputType(name: string | AllNexusInputTypeDefs | NexusWrappedType<AllNexusInputTypeDefs>): GraphQLPossibleInputs;
    protected getOutputType(name: string | AllNexusOutputTypeDefs | NexusWrappedType<any>): GraphQLPossibleOutputs;
    protected getObjectType(name: string | NexusObjectTypeDef<string>): GraphQLObjectType;
    protected getOrBuildType(name: string | AllNexusNamedTypeDefs | NexusWrappedType<AllNexusNamedTypeDefs>, fromObject?: boolean): GraphQLNamedType;
    protected getSubscribe(fieldConfig: NexusOutputFieldDef): GraphQLFieldResolver<any, any, {
        [argName: string]: any;
    }> | undefined;
    protected getResolver(fieldConfig: NexusOutputFieldDef, typeConfig: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any>, forInterface?: boolean): GraphQLFieldResolver<any, any, {
        [argName: string]: any;
    }> | undefined;
    missingResolveType(name: string, location: "union" | "interface"): () => null;
    protected walkInputType<T extends NexusShapedInput>(obj: T): T;
    addDynamicInputFields(block: InputDefinitionBlock<any>, isList: boolean): void;
    addDynamicOutputMembers(block: OutputDefinitionBlock<any>, isList: boolean): void;
    addDynamicScalar(methodName: string, typeName: string, block: OutputDefinitionBlock<any> | InputDefinitionBlock<any>): void;
    protected walkOutputType<T extends NexusShapedOutput>(obj: T): T;
    protected walkInterfaceType(obj: NexusInterfaceTypeConfig<any>): NexusInterfaceTypeConfig<any>;
    protected maybeTraverseOutputType(type: NexusOutputFieldDef): void;
    protected maybeTraverseInputType(type: NexusInputFieldDef): void;
    protected walkNamedTypes(namedType: GraphQLNamedType): void;
    protected addObjectField(obj: GraphQLField<any, any>): void;
}
export declare function wrapAuthorize(resolver: GraphQLFieldResolver<any, any>, authorize: AuthorizeResolver<string, any>): GraphQLFieldResolver<any, any>;
export declare type DynamicFieldDefs = {
    dynamicInputFields: DynamicInputFields;
    dynamicOutputFields: DynamicOutputFields;
    dynamicOutputProperties: DynamicOutputProperties;
};
export interface BuildTypes<TypeMapDefs extends Record<string, GraphQLNamedType>> {
    typeMap: TypeMapDefs;
    dynamicFields: DynamicFieldDefs;
    rootTypings: RootTypings;
    missingTypes: Record<string, MissingType>;
}
/**
 * Builds the types, normalizing the "types" passed into the schema for a
 * better developer experience. This is primarily useful for testing
 * type generation
 */
export declare function buildTypes<TypeMapDefs extends Record<string, GraphQLNamedType> = any>(types: any, config?: BuilderConfig, schemaBuilder?: SchemaBuilder): BuildTypes<TypeMapDefs>;
/**
 * Internal build types woring with config rather than options.
 */
export declare function buildTypesInternal<TypeMapDefs extends Record<string, GraphQLNamedType> = any>(types: any, config: InternalBuilderConfig, schemaBuilder?: SchemaBuilder): BuildTypes<TypeMapDefs>;
export declare type NexusSchemaExtensions = {
    rootTypings: RootTypings;
    dynamicFields: DynamicFieldDefs;
};
export declare type NexusSchema = GraphQLSchema & {
    extensions: Record<string, any> & {
        nexus: NexusSchemaExtensions;
    };
};
/**
 * Builds the schema, we may return more than just the schema
 * from this one day.
 */
export declare function makeSchemaInternal(config: InternalSchemaConfig, schemaBuilder?: SchemaBuilder): {
    schema: NexusSchema;
    missingTypes: Record<string, MissingType>;
};
/**
 * Defines the GraphQL schema, by combining the GraphQL types defined
 * by the GraphQL Nexus layer or any manually defined GraphQLType objects.
 *
 * Requires at least one type be named "Query", which will be used as the
 * root query type.
 */
export declare function makeSchema(config: SchemaConfig): GraphQLSchema;
/**
 * Like makeSchema except that typegen is always run
 * and waited upon.
 */
export declare function generateSchema(config: SchemaConfig): Promise<NexusSchema>;
export {};
