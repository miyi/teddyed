"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var dynamicMethod_1 = require("../dynamicMethod");
var objectType_1 = require("../definitions/objectType");
var args_1 = require("../definitions/args");
var relayConnectionMap = new Map();
var pageInfo;
exports.RelayConnectionFieldMethod = dynamicMethod_1.dynamicOutputMethod({
    name: "relayConnectionField",
    typeDefinition: "\n    <FieldName extends string>(fieldName: FieldName, opts: {\n      type: NexusGenObjectNames | NexusGenInterfaceNames | core.NexusObjectTypeDef<string> | core.NexusInterfaceTypeDef<string>,\n      edges: core.SubFieldResolver<TypeName, FieldName, \"edges\">,\n      pageInfo: core.SubFieldResolver<TypeName, FieldName, \"pageInfo\">,\n      args?: Record<string, core.NexusArgDef<string>>,\n      nullable?: boolean,\n      description?: string\n    }): void\n  ",
    factory: function (_a) {
        var t = _a.typeDef, _b = _a.args, fieldName = _b[0], config = _b[1];
        if (!config.type) {
            throw new Error("Missing required property \"type\" from relayConnection field " + fieldName);
        }
        var typeName = typeof config.type === "string" ? config.type : config.type.name;
        pageInfo =
            pageInfo ||
                objectType_1.objectType({
                    name: "ConnectionPageInfo",
                    definition: function (p) {
                        p.boolean("hasNextPage");
                        p.boolean("hasPreviousPage");
                    },
                });
        if (config.list) {
            throw new Error("Collection field " + fieldName + "." + typeName + " cannot be used as a list.");
        }
        if (!relayConnectionMap.has(typeName)) {
            relayConnectionMap.set(typeName, objectType_1.objectType({
                name: typeName + "RelayConnection",
                definition: function (c) {
                    c.list.field("edges", {
                        type: objectType_1.objectType({
                            name: typeName + "Edge",
                            definition: function (e) {
                                e.id("cursor");
                                e.field("node", { type: config.type });
                            },
                        }),
                    });
                    c.field("pageInfo", { type: pageInfo });
                },
            }));
        }
        t.field(fieldName, {
            type: relayConnectionMap.get(typeName),
            args: tslib_1.__assign({ first: args_1.intArg(), after: args_1.stringArg(), last: args_1.intArg(), before: args_1.stringArg() }, config.args),
            nullable: config.nullable,
            description: config.description,
            resolve: function (root, args, ctx, info) {
                var edgeResolver = function () {
                    var fArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        fArgs[_i] = arguments[_i];
                    }
                    return config.edges(root, args, ctx, fArgs[3]);
                };
                var pageInfoResolver = function () {
                    var fArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        fArgs[_i] = arguments[_i];
                    }
                    return config.pageInfo(root, args, ctx, fArgs[3]);
                };
                return {
                    edges: edgeResolver,
                    pageInfo: pageInfoResolver,
                };
            },
        });
    },
});
//# sourceMappingURL=relayConnection.js.map